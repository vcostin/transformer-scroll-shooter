/**
 * EventDispatcher - Pure Functional Implementation  
 * NO CLASSES, NO `this`, NO COMPATIBILITY LAYERS
 * 
 * This is a clean functional event system with:
 * - Curried event handlers for dependency injection
 * - Pure functions for event management
 * - No global state or singletons
 * - Pattern-based event matching
 */

// ===== PURE EVENT FUNCTIONS =====

/**
 * Check if an event matches a pattern
 * @param {string} eventName - The event name to check
 * @param {string} pattern - The pattern to match against (supports wildcards)
 * @returns {boolean} True if the event matches the pattern
 */
const matchesPattern = (eventName, pattern) => {
  if (pattern === '*') return true
  if (pattern === eventName) return true
  
  // Support simple wildcards
  if (pattern.includes('*')) {
    const regex = new RegExp(pattern.replace(/\*/g, '.*'))
    return regex.test(eventName)
  }
  
  return false
}

/**
 * Create a unique subscription ID
 * @returns {string} Unique ID
 */
const createSubscriptionId = () => {
  return `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
}

// ===== CURRIED EVENT FUNCTIONS =====

/**
 * Creates event dispatcher functions with dependency injection
 * @param {Object} options - Configuration options
 * @returns {Object} Event dispatcher functions
 */
export const createEventDispatcher = (options = {}) => {
  const config = {
    enableLogging: false,
    maxListeners: 100,
    enablePatterns: true,
    ...options
  }
  
  // Private event storage (closure)
  const listeners = new Map()
  const eventHistory = []
  let isEmitting = false
  const pendingEvents = []
  
  // Pure helper to log events
  const logEvent = (eventName, data) => {
    if (config.enableLogging) {
      console.log(`ðŸ”¥ Event: ${eventName}`, data)
    }
  }
  
  // Pure helper to add to history
  const addToHistory = (eventName, data) => {
    eventHistory.push({
      event: eventName,
      data,
      timestamp: Date.now()
    })
    
    // Limit history size
    if (eventHistory.length > 1000) {
      eventHistory.shift()
    }
  }
  
  return {
    
    // Curried event listener registration
    on: (eventPattern) => (callback) => {
      if (typeof callback !== 'function') {
        throw new Error('Event callback must be a function')
      }
      
      const subscriptionId = createSubscriptionId()
      
      if (!listeners.has(eventPattern)) {
        listeners.set(eventPattern, new Map())
      }
      
      listeners.get(eventPattern).set(subscriptionId, callback)
      
      // Check max listeners
      let totalListeners = 0
      for (const patternMap of listeners.values()) {
        totalListeners += patternMap.size
      }
      
      if (totalListeners > config.maxListeners) {
        console.warn(`Event dispatcher has ${totalListeners} listeners (max: ${config.maxListeners})`)
      }
      
      logEvent('listener:added', { pattern: eventPattern, subscriptionId })
      
      // Return unsubscribe function
      return () => {
        const patternMap = listeners.get(eventPattern)
        if (patternMap) {
          patternMap.delete(subscriptionId)
          if (patternMap.size === 0) {
            listeners.delete(eventPattern)
          }
        }
        logEvent('listener:removed', { pattern: eventPattern, subscriptionId })
      }
    },
    
    // Curried once listener (auto-unsubscribe after first call)
    once: (eventPattern) => (callback) => {
      const unsubscribe = createEventDispatcher(config).on(eventPattern)((data) => {
        unsubscribe()
        callback(data)
      })
      return unsubscribe
    },
    
    // Event emission with pattern matching
    emit: (eventName, data = {}) => {
      if (isEmitting) {
        // Prevent infinite loops by queuing nested events
        pendingEvents.push({ eventName, data })
        return
      }
      
      logEvent(eventName, data)
      addToHistory(eventName, data)
      
      isEmitting = true
      
      try {
        // Find all matching listeners
        const matchingCallbacks = []
        
        for (const [pattern, callbackMap] of listeners.entries()) {
          if (config.enablePatterns ? matchesPattern(eventName, pattern) : pattern === eventName) {
            for (const callback of callbackMap.values()) {
              matchingCallbacks.push(callback)
            }
          }
        }
        
        // Execute all matching callbacks
        for (const callback of matchingCallbacks) {
          try {
            callback(data, eventName)
          } catch (error) {
            console.error(`Event listener error for ${eventName}:`, error)
          }
        }
        
      } finally {
        isEmitting = false
        
        // Process any queued events
        if (pendingEvents.length > 0) {
          const nextEvent = pendingEvents.shift()
          setImmediate(() => {
            createEventDispatcher(config).emit(nextEvent.eventName, nextEvent.data)
          })
        }
      }
    },
    
    // Remove all listeners for a pattern
    removeAllListeners: (eventPattern) => {
      if (eventPattern) {
        listeners.delete(eventPattern)
        logEvent('listeners:removed', { pattern: eventPattern })
      } else {
        listeners.clear()
        logEvent('listeners:cleared', {})
      }
    },
    
    // Get listener count for debugging
    getListenerCount: (eventPattern) => {
      if (eventPattern) {
        const patternMap = listeners.get(eventPattern)
        return patternMap ? patternMap.size : 0
      }
      
      let total = 0
      for (const patternMap of listeners.values()) {
        total += patternMap.size
      }
      return total
    },
    
    // Get event history
    getEventHistory: () => [...eventHistory],
    
    // Clear event history
    clearHistory: () => {
      eventHistory.length = 0
    },
    
    // For testing - get all listener patterns
    _getListenerPatterns: () => Array.from(listeners.keys())
  }
}

// ===== GAME-SPECIFIC EVENT HELPERS =====

/**
 * Create game-specific event functions
 * @param {Object} eventDispatcher - Base event dispatcher
 * @returns {Object} Game-specific event functions
 */
export const createGameEvents = (eventDispatcher) => ({
  
  // Player events
  playerMoved: (position) => eventDispatcher.emit('game:player:moved', position),
  playerHit: (damage) => eventDispatcher.emit('game:player:hit', { damage }),
  playerPoweredUp: (powerType) => eventDispatcher.emit('game:player:powerup', { powerType }),
  
  // Enemy events  
  enemySpawned: (enemy) => eventDispatcher.emit('game:enemy:spawned', enemy),
  enemyDestroyed: (enemyId, score) => eventDispatcher.emit('game:enemy:destroyed', { enemyId, score }),
  
  // Game state events
  gameStarted: () => eventDispatcher.emit('game:started', {}),
  gamePaused: (reason) => eventDispatcher.emit('game:paused', { reason }),
  gameResumed: (source) => eventDispatcher.emit('game:resumed', { source }),
  gameOver: (score) => eventDispatcher.emit('game:over', { score }),
  
  // UI events
  menuOpened: (menuType) => eventDispatcher.emit('ui:menu:opened', { menuType }),
  menuClosed: (menuType) => eventDispatcher.emit('ui:menu:closed', { menuType }),
  settingChanged: (setting, value) => eventDispatcher.emit('ui:setting:changed', { setting, value }),
  
  // Audio events
  soundPlayed: (soundName) => eventDispatcher.emit('audio:sound:played', { soundName }),
  musicChanged: (trackName) => eventDispatcher.emit('audio:music:changed', { trackName }),
  
  // Subscribe to game events with curried functions
  onPlayerMoved: (callback) => eventDispatcher.on('game:player:moved')(callback),
  onPlayerHit: (callback) => eventDispatcher.on('game:player:hit')(callback),
  onEnemySpawned: (callback) => eventDispatcher.on('game:enemy:spawned')(callback),
  onGamePaused: (callback) => eventDispatcher.on('game:paused')(callback),
  onGameResumed: (callback) => eventDispatcher.on('game:resumed')(callback),
  
  // Pattern-based subscriptions
  onAnyPlayerEvent: (callback) => eventDispatcher.on('game:player:*')(callback),
  onAnyEnemyEvent: (callback) => eventDispatcher.on('game:enemy:*')(callback),
  onAnyUIEvent: (callback) => eventDispatcher.on('ui:*')(callback),
  onAnyAudioEvent: (callback) => eventDispatcher.on('audio:*')(callback)
})

// ===== TESTING UTILITIES =====

/**
 * Create a mock event dispatcher for testing
 * @param {Object} options - Configuration options
 * @returns {Object} Mock event dispatcher with testing utilities
 */
export const createMockEventDispatcher = (options = {}) => {
  const dispatcher = createEventDispatcher({ enableLogging: true, ...options })
  
  return {
    ...dispatcher,
    
    // Testing helpers
    expectEvent: (eventName) => {
      const history = dispatcher.getEventHistory()
      const found = history.some(entry => entry.event === eventName)
      if (!found) {
        throw new Error(`Expected event '${eventName}' was not emitted`)
      }
    },
    
    expectNoEvent: (eventName) => {
      const history = dispatcher.getEventHistory()
      const found = history.some(entry => entry.event === eventName)
      if (found) {
        throw new Error(`Unexpected event '${eventName}' was emitted`)
      }
    },
    
    getEmittedEvents: () => dispatcher.getEventHistory().map(entry => entry.event),
    
    clearTestHistory: () => dispatcher.clearHistory()
  }
}

/**
 * Create an event spy for testing
 * @param {Object} eventDispatcher - Event dispatcher to spy on
 * @param {string} eventPattern - Pattern to spy on
 * @returns {Object} Spy object with testing utilities
 */
export const createEventSpy = (eventDispatcher, eventPattern) => {
  const calls = []
  
  const unsubscribe = eventDispatcher.on(eventPattern)((data, eventName) => {
    calls.push({ eventName, data, timestamp: Date.now() })
  })
  
  return {
    calls,
    callCount: () => calls.length,
    lastCall: () => calls[calls.length - 1],
    firstCall: () => calls[0],
    reset: () => calls.length = 0,
    destroy: unsubscribe,
    
    // Testing assertions
    expectCalled: (times) => {
      if (times !== undefined && calls.length !== times) {
        throw new Error(`Expected ${times} calls, got ${calls.length}`)
      }
      if (times === undefined && calls.length === 0) {
        throw new Error('Expected at least one call, got none')
      }
    },
    
    expectNotCalled: () => {
      if (calls.length > 0) {
        throw new Error(`Expected no calls, got ${calls.length}`)
      }
    }
  }
}
